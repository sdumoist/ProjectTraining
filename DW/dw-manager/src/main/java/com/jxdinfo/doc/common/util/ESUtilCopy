/*
package com.jxdinfo.doc.common.util;

import com.jxdinfo.doc.common.docutil.model.ESResponse;
import com.jxdinfo.doc.manager.docmanager.dao.DocInfoMapper;
import org.elasticsearch.action.delete.DeleteResponse;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.transport.TransportClient;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.text.Text;
import org.elasticsearch.common.transport.TransportAddress;
import org.elasticsearch.index.query.*;
import org.elasticsearch.rest.RestStatus;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;
import org.elasticsearch.search.sort.SortOrder;
import org.elasticsearch.transport.client.PreBuiltTransportClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;

*/
/**
 * 类的用途：ElasticSearch 工具类<p>
 * 创建日期：2018年8月28日 <br>
 * 修改历史：<br>
 * 修改日期：2018年8月28日 <br>
 * 修改作者：WangBinBin <br>
 * 修改内容：修改内容 <br>
 * @author WangBinBin
 * @version 1.0
 *//*

@Service
public class ESUtilCopy {

    @Value("${docbase.es-base}")
    private String INDEX_OF_DOCBASE;


    @Value("${examine.using}")
    private boolean examineUsingFlag;

    @Resource
    private DocInfoMapper docInfoMapper;

    private String TYPE_OF_DOCBASE = "doc";

    private String[] FIELDS_OF_DOC = { "title", "category", "tags", "content", "readType" };

    private int SIZE_OF_PAGE = 10;

    private String hosts;

    private TransportClient client = null;

    */
/**
     * 单例，只在项目启动过程初始化一遍TransportClient
     * @Title:ESUtil
     * @param hosts
     *//*

    public ESUtilCopy(@Value("${docbase.es-host}") String hosts) {
        this.hosts = hosts;
        client = new PreBuiltTransportClient(Settings.EMPTY);
        for (String host : this.hosts.split(",")) {
            try {
                String address = host.split(":")[0];
                int port = Integer.parseInt(host.split(":")[1]);
                client.addTransportAddress(new TransportAddress(InetAddress.getByName(address), port));
            } catch (UnknownHostException e) {
                e.printStackTrace();
            }
        }
    }

    */
/**
     * 只调用一次，用于初始化ES索引
     *
     * @throws IOException
     *//*

    public void createIndex() throws IOException {

        if (this.client.admin().indices().prepareExists(INDEX_OF_DOCBASE).get().isExists()) {
            this.client.admin().indices().prepareDelete(INDEX_OF_DOCBASE).get();
        }
        Settings settings = Settings.builder().put("index.number_of_shards", 3).put("index.number_of_replicas", 2)
                .build();

        Map<String, Object> mappings = new HashMap<>();
        Map<String, Object> types = new HashMap<>();
        Map<String, Object> properties = new HashMap<>();
        for (String field : FIELDS_OF_DOC) {
            Map<String, Object> property = new HashMap<>();
            property.put("type", "text");
            property.put("analyzer", "ik_max_word");
            property.put("search_analyzer", "ik_max_word");
            properties.put(field, property);
        }
        types.put("properties", properties);
        mappings.put(TYPE_OF_DOCBASE, types);

        this.client.admin().indices().prepareCreate(INDEX_OF_DOCBASE).setSettings(settings)
                .addMapping(TYPE_OF_DOCBASE, mappings).get();
    }

    */
/**
     * 为文档创建索引
     * @param docId
     * @param source
     * @return 新建索引时返回201 索引存在时返回200
     *//*

    public int index(String docId, Map<String, Object> source) {
        System.out.println("传输的值为："+source);
        IndexResponse response = this.client.prepareIndex(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, docId).setSource(source)
                .get();
        RestStatus status = response.status();
        return status.getStatus();
    }
    */
/**
     * 获取索引
     * *@param docId  索引ID
     * @return 索引信息
     *//*

    public Map<String, Object> getIndex(String docId) {
        GetResponse response = this.client.prepareGet(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, docId).get();
        if (response.isExists()) {
            return response.getSourceAsMap();
        }
        return null;
    }

    */
/**
     * 将一个文件索引复制到另一个文件中
     * *@param oldDocId  已经存在的docID
     * @param newDocId  新上传的docID
     * @return 新建索引时返回201 索引存在时返回200
     *//*

    public int copyIndex(String oldDocId ,String newDocId){
        //根据已经存在的文件ID获取文件索引信息
        GetResponse response = this.client.prepareGet(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, oldDocId).get();
        Map<String, Object> sourceMap = response.getSourceAsMap();
        System.out.println("****************************************************************************秒传是输出的索引："+sourceMap);
            sourceMap.put("recycle", "1");
        //将获取的索引信息存放到新文件中
        IndexResponse indexResponse = this.client.prepareIndex(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, newDocId).setSource(sourceMap).get();
        RestStatus status = indexResponse.status();

        return status.getStatus();
    }

    */
/**
     * 根据索引数据id删除索引
     * @Title: deleteIndex 
     * @author: WangBinBin
     * @param docId
     * @return
     *//*

    public int deleteIndex(String docId) {
        DeleteResponse response = this.client.prepareDelete(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, docId).get();
        RestStatus status = response.status();
        return status.getStatus();
    }

    */
/**
     * 根据索引数据ID更新索引
     * @Title: updateIndex 
     * @author: WangBinBin
     * @param docId
     * @param source
     * @return
     *//*

    public int updateIndex(String docId, Map<String, Object> source) {
        UpdateResponse response = this.client.prepareUpdate(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, docId).setDoc(source)
                .get();
        RestStatus status = response.status();
        return status.getStatus();
    }


    */
/**
     *  根据索引数据ID更新索引,存在则更新，不存在则新增
     * @Title: upsertIndex 
     * @author: WangBinBin
     * @param docId
     * @param source
     * @return
     * @throws ExecutionException
     * @throws InterruptedException
     *//*

    public int upsertIndex(String docId, Map<String, Object> source) throws ExecutionException, InterruptedException {
        IndexRequest indexRequest = new IndexRequest(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, docId).source(source);
        UpdateRequest updateRequest = new UpdateRequest(INDEX_OF_DOCBASE, TYPE_OF_DOCBASE, docId).doc(source)
                .upsert(indexRequest);
        UpdateResponse response = this.client.update(updateRequest).get();
        return response.status().getStatus();
    }

    */
/**
     * 处理高亮显示字段
     * @Title: handleHits 
     * @author: WangBinBin
     * @param response
     * @return
     *//*

    private ESResponse<Map<String, Object>> handleHits(SearchResponse response) {

        SearchHits hits = response.getHits();
        ESResponse<Map<String, Object>> result = new ESResponse<>();
        long totalHits = hits.totalHits;
        result.setTotal(totalHits);
        int totalPage = (int) (totalHits / 10) + 1;
        result.setTotalPages(totalPage);
        
        List<Map<String, Object>> items = result.getItems();

        Iterator<SearchHit> iterator = hits.iterator();
        while (iterator.hasNext()) {
            SearchHit searchHit = iterator.next();// 每个查询对象
            Map<String, Object> source = searchHit.getSourceAsMap();
            source.put("id", searchHit.getId());
            // 将高亮处理后的内容，替换原有内容（原有内容，可能会出现显示不全）
            Map<String, HighlightField> hightlightFields = searchHit.getHighlightFields();
            Iterator<String> hightlightKeys = hightlightFields.keySet().iterator();
            while (hightlightKeys.hasNext()) {
                String key = hightlightKeys.next();
                HighlightField field = hightlightFields.get(key);
                // 获取到原有内容中 每个高亮显示 集中位置fragment就是高亮片段
                Text[] fragments = field.fragments();
                StringBuffer sb = new StringBuffer();
                for (Text text : fragments) {
                    sb.append(text);
                }
                source.put(key, sb.toString());
            }
            items.add(source);
        }

        return result;
    }

    private SearchResponse doQuery(QueryBuilder queryBuilder, int page, Integer size) {
        if(size==null){
            size=SIZE_OF_PAGE;
        }
        // 启用高亮
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        for (String field : FIELDS_OF_DOC) {
            HighlightBuilder.Field fld = new HighlightBuilder.Field(field);
            fld.highlighterType("unified");
            highlightBuilder.field(fld);
        }
        String[] source = new String[] { "title", "upDate" };
        return this.client.prepareSearch(INDEX_OF_DOCBASE).setFetchSource(source, new String[0])
                .setFrom((page - 1) * size).setSize(size).highlighter(highlightBuilder)
                .setQuery(queryBuilder).addSort("_score", SortOrder.DESC).addSort("upDate", SortOrder.DESC).get();
    }

    */
/**
     * 单字段查询
     *
     * @param field
     * @param keyword
     *//*

    public ESResponse<Map<String, Object>> matchQuery(String field, String keyword, int page, int size) {
        MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(field, keyword);
        SearchResponse response = doQuery(queryBuilder, page, size);
        return handleHits(response);
    }

    */
/**
     * 多字段查询
     * @Title: multiMatchQuery 
     * @author: WangBinBin
     * @param keyword
     * @param page
     * @param adminFlag
     * @return
     *//*

    public ESResponse<Map<String, Object>> multiMatchQuery(String keyword, int page, Boolean adminFlag, Integer size) {
        // 获取当前登录人所拥有的所有权限
        String[] permission = PrivilegeUtil.getPremission();
        // 关键字进行过滤
        MultiMatchQueryBuilder queryBuilder = QueryBuilders.multiMatchQuery(keyword, FIELDS_OF_DOC).analyzer("ik_max_word");
        // 权限条件过滤 因为es会自动对中文进行分词，所以在此处权限查询的时候需要加.keyword。防止分词
        TermsQueryBuilder termsQueryBuilder = QueryBuilders.termsQuery("permission.keyword", permission);
        // 回收站条件过滤 不在回收站的为0在回收站的为1
        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("recycle", "1");

        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder);
        // 如果是文库超级管理员，不加权限限制
        if (!adminFlag) {
            boolQueryBuilder.must(termsQueryBuilder);
        }
        SearchResponse response = doQuery(boolQueryBuilder, page,size);
        return handleHits(response);
    }
    */
/**
     * 多字段查询
     * @Title: multiMatchQuery
     * @author: WangBinBin
     * @param keyword
     * @param page
     * @param adminFlag
     * @return
     *//*

    public ESResponse<Map<String, Object>> multiMatchQuery(String keyword, int page, Boolean adminFlag, Integer size, String userId) {
        // 获取当前登录人所拥有的所有权限
        String[] permission = PrivilegeUtil.getPremission(userId);
        // 关键字进行过滤
        MultiMatchQueryBuilder queryBuilder = QueryBuilders.multiMatchQuery(keyword, FIELDS_OF_DOC).analyzer("ik_max_word");
        // 权限条件过滤 因为es会自动对中文进行分词，所以在此处权限查询的时候需要加.keyword。防止分词
        TermsQueryBuilder termsQueryBuilder = QueryBuilders.termsQuery("permission.keyword", permission);
        // 回收站条件过滤 不在回收站的为0在回收站的为1
        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("recycle", "1");

        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder);
        // 如果是文库超级管理员，不加权限限制
        if (!adminFlag) {
            boolQueryBuilder.must(termsQueryBuilder);
        }
        SearchResponse response = doQuery(boolQueryBuilder, page,size);
        return handleHits(response);
    }

    public ESResponse<Map<String, Object>> onlyMatchWordQuery(String keyword, int size){
        //对标题进行关键字匹配
        MatchPhraseQueryBuilder termQueryBuilder = QueryBuilders.matchPhraseQuery("title",keyword);
        //对标签进行关键字匹配
        MatchPhraseQueryBuilder termQueryBuilder2 = QueryBuilders.matchPhraseQuery("tags",keyword);
        //对文档内容进行关键字匹配
        MatchPhraseQueryBuilder termQueryBuilder3 = QueryBuilders.matchPhraseQuery("content",keyword);
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery().should(termQueryBuilder).should(termQueryBuilder2).should(termQueryBuilder3);
        SearchResponse response = doQuery(boolQueryBuilder,1,size);
        return handleHits(response);
    }

    */
/**
     * 带文件类型过滤查询
     *
     * @param keyword
     * @param contentType
     * @param page
     * @return
     *//*

    public ESResponse<Map<String, Object>> boolQuery(String keyword, String contentType, int page,
                                                     Boolean adminFlag, Integer size, String tagString) {
        // 获取当前登录人所拥有的所有权限
        String[] permission = PrivilegeUtil.getPremission();
        // 关键字进行过滤
        MultiMatchQueryBuilder queryBuilder = QueryBuilders.multiMatchQuery(keyword, FIELDS_OF_DOC).analyzer("ik_max_word");
        // 权限条件过滤
        TermsQueryBuilder termsQueryBuilder = QueryBuilders.termsQuery("permission.keyword", permission);
        // 回收站条件过滤 不在回收站的为0在回收站的为1
        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("recycle", "1");
        // 文件类型过滤
        //文档  word：application/msword 、application/vnd.openxmlformats-officedocument.wordprocessingml.document  、application/rtf
        //    Excel：spreadsheetml     PPT：application/vnd.openxmlformats-officedocument.presentationml.presentation
        //      pdf:application/pdf    txt：text/plain
        //     图片：image       视频：video/mp4           音频：application/octet-stream.text/plain，audio/mpeg
        TermsQueryBuilder queryStringQueryBuilder1 = null;
        QueryBuilder queryStringQueryBuilder2 = null;
        QueryBuilder queryStringQueryBuilder3 = null;
        BoolQueryBuilder boolQueryBuilder = null;
        //先判断所有
        if("allword".equals(contentType)){//对文档进行过滤
            queryStringQueryBuilder1 = QueryBuilders.termsQuery("contentType.keyword","application/msword","spreadsheetml",
                    "application/pdf","application/vnd.openxmlformats-officedocument.presentationml.presentation",
                    "application/vnd.openxmlformats-officedocument.wordprocessingml.document","text/plain","application/vnd.ms-excel","application/vnd.ms-powerpoint","application/rtf",
                    "application/vnd.openxmlformats-officedocument.presentationml.presentation");
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder1);
        }else if("video".equals(contentType)){  //对视频进行过滤
            queryStringQueryBuilder1 = QueryBuilders.termsQuery("contentType.keyword","application/mp4","video/avi","video/mp4",
                    "video/mpeg4","video/mpeg4","video/x-ms-wmv","video/x-sgi-movie");
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder1);
        }else if("component".equals(contentType)){  //对组件进行过滤
            queryStringQueryBuilder1 = QueryBuilders.termsQuery("contentType.keyword","component");
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder1);
        }else if("notimage".equals(contentType)){ //对非图片进行过滤
            contentType  = "image";
            String psd="contentType:*photoshop*";
            String docType = "contentType:*" + contentType + "*";
            if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
                docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
            }
            queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);
            BoolQueryBuilder boolQueryBuilder2 = QueryBuilders.boolQuery().must(queryStringQueryBuilder2).mustNot( QueryBuilders.queryStringQuery(psd));
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).mustNot(boolQueryBuilder2);
        }else if("image".equals(contentType)){   //对图片进行过滤
            String docType = "contentType:*" + contentType + "*";
            String psd="contentType:*photoshop*";
            if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
                docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
            }
            queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);

            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).
                    must(queryStringQueryBuilder2).mustNot(QueryBuilders.queryStringQuery(psd));
            //对图片传输的标签进行判定
            if(tagString!=null&&!"".equals(tagString)&& tagString.split("\\|").length!=0) {
                //将前台拼装的分类传过来
                String[] strs = tagString.split("\\|");
                for (int i = 0; i < strs.length; i++) {
                    // 记录一个分类中多个标签的情况
                    BoolQueryBuilder builderTag = QueryBuilders.boolQuery();
                    // 将标签按照逗号分隔开
                    String[] strs_tags = strs[i].split(",");
                    // 将一个分类中的多个标签拼装，达到OR的效果
                    for (int j = 0; j < strs_tags.length; j++) {
                        String strs_tag = strs_tags[j];
                        builderTag.should(QueryBuilders.wildcardQuery("tags.keyword", "*" + strs_tag + "*"));
                    }
                    //将拼装后的标签添加到boolQueryBuilder中，达到AND的效果
                    boolQueryBuilder = boolQueryBuilder.must(builderTag);
                }

//                if(strs.length==0){
//                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2);
//                }else if(strs.length==1){
//                    QueryBuilder queryImage1 = QueryBuilders.wildcardQuery("tags.keyword", "*铁路*");
//                    QueryBuilder queryImage2 = QueryBuilders.wildcardQuery("tags.keyword", "*电力*");
//                    BoolQueryBuilder boolQueryBuilder2 = QueryBuilders.boolQuery().should(queryImage1).should(queryImage2);
//                    boolQueryBuilder =  QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2).must(boolQueryBuilder2);
//                }else if(strs.length==2){
//                    QueryBuilder queryImage1 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[0]+"*");
//                    QueryBuilder queryImage2 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[1]+"*");
//                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2).must(queryImage1).must(queryImage2);
//                }else if(strs.length==3){
//                    QueryBuilder queryImage1 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[0]+"*");
//                    QueryBuilder queryImage2 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[1]+"*");
//                    QueryBuilder queryImage3 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[2]+"*");
//                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2).must(queryImage1).must(queryImage2).must(queryImage3);
//                }
            }
        }else{ //其他过滤
            String docType = "";
            String docType1 = "";
            if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
                if(contentType.equals("presentationml")){
                    docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
                    queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);

                    contentType= "powerpoint";
                    docType1 = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
                    queryStringQueryBuilder3 = QueryBuilders.queryStringQuery(docType1);
                    QueryBuilder query = QueryBuilders.boolQuery().
                    should(queryStringQueryBuilder2).should(queryStringQueryBuilder3);
                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(query);
                }else if(contentType.equals("spreadsheetml")){
                    docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
                    queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);

                    contentType= "excel";
                    docType1 = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
                    queryStringQueryBuilder3 = QueryBuilders.queryStringQuery(docType1);
                    QueryBuilder query = QueryBuilders.boolQuery().
                            should(queryStringQueryBuilder2).should(queryStringQueryBuilder3);
                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(query);
                }else{
                    docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
                    queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);
                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2);
                }

            }   else {
                 docType = "contentType:*" + contentType + "*";
                queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);
                boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2);
            }


        }
//        String docType = "contentType:*" + contentType + "*";
//        if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
//            docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
//        }
//        QueryStringQueryBuilder queryStringQueryBuilder = QueryBuilders.queryStringQuery(docType);
//        QueryBuilder queryStringQueryBuilder = QueryBuilders.wildcardQuery("contentType", "*word*");

        // 如果是文库超级管理员，不加权限限制
        if (!adminFlag) {
            boolQueryBuilder.must(termsQueryBuilder);
        }
        SearchResponse response = doQuery(boolQueryBuilder, page,size);
        return handleHits(response);
    }
    */
/**
     * 带文件类型过滤查询
     *
     * @param keyword
     * @param contentType
     * @param page
     * @return
     *//*

    public ESResponse<Map<String, Object>> boolQuery(String keyword, String contentType, int page,
                                                     Boolean adminFlag, Integer size, String tagString, String userId) {
        // 获取当前登录人所拥有的所有权限
        String[] permission = PrivilegeUtil.getPremission(userId);
        // 关键字进行过滤
        MultiMatchQueryBuilder queryBuilder = QueryBuilders.multiMatchQuery(keyword, FIELDS_OF_DOC).analyzer("ik_max_word");
        // 权限条件过滤
        TermsQueryBuilder termsQueryBuilder = QueryBuilders.termsQuery("permission.keyword", permission);
        // 回收站条件过滤 不在回收站的为0在回收站的为1
        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery("recycle", "1");
        // 文件类型过滤
        //文档  word：application/msword 、application/vnd.openxmlformats-officedocument.wordprocessingml.document  、application/rtf
        //    Excel：spreadsheetml     PPT：application/vnd.openxmlformats-officedocument.presentationml.presentation
        //      pdf:application/pdf    txt：text/plain
        //     图片：image       视频：video/mp4           音频：application/octet-stream.text/plain，audio/mpeg
        TermsQueryBuilder queryStringQueryBuilder1 = null;
        QueryBuilder queryStringQueryBuilder2 = null;
        BoolQueryBuilder boolQueryBuilder = null;
        //先判断所有
        if("allword".equals(contentType)){//对文档进行过滤
            queryStringQueryBuilder1 = QueryBuilders.termsQuery("contentType.keyword","application/msword","spreadsheetml",
                    "application/pdf","application/vnd.openxmlformats-officedocument.presentationml.presentation",
                    "application/vnd.openxmlformats-officedocument.wordprocessingml.document","text/plain","application/rtf",
                    "application/vnd.openxmlformats-officedocument.presentationml.presentation");
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder1);
        }else if("video".equals(contentType)){  //对视频进行过滤
            queryStringQueryBuilder1 = QueryBuilders.termsQuery("contentType.keyword","application/mp4","video/avi",
                    "video/mpeg4","video/mpeg4","video/x-ms-wmv","video/x-sgi-movie");
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder1);
        }else if("notimage".equals(contentType)){ //对非图片进行过滤
            contentType  = "image";
            String psd="contentType:*photoshop*";
            String docType = "contentType:*" + contentType + "*";
            if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
                docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
            }
            queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);
            BoolQueryBuilder boolQueryBuilder2 = QueryBuilders.boolQuery().must(queryStringQueryBuilder2).mustNot( QueryBuilders.queryStringQuery(psd));
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).mustNot(boolQueryBuilder2);
        }else if("image".equals(contentType)){   //对图片进行过滤
            String docType = "contentType:*" + contentType + "*";
            String psd="contentType:*photoshop*";
            if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
                docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
            }
            queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);

            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).
                    must(queryStringQueryBuilder2).mustNot(QueryBuilders.queryStringQuery(psd));
            //对图片传输的标签进行判定
            if(tagString!=null&&!"".equals(tagString)&& tagString.split("\\|").length!=0) {
                //将前台拼装的分类传过来
                String[] strs = tagString.split("\\|");
                for (int i = 0; i < strs.length; i++) {
                    // 记录一个分类中多个标签的情况
                    BoolQueryBuilder builderTag = QueryBuilders.boolQuery();
                    // 将标签按照逗号分隔开
                    String[] strs_tags = strs[i].split(",");
                    // 将一个分类中的多个标签拼装，达到OR的效果
                    for (int j = 0; j < strs_tags.length; j++) {
                        String strs_tag = strs_tags[j];
                        builderTag.should(QueryBuilders.wildcardQuery("tags", "*" + strs_tag + "*"));
                    }
                    //将拼装后的标签添加到boolQueryBuilder中，达到AND的效果
                    boolQueryBuilder = boolQueryBuilder.must(builderTag);
                }

//                if(strs.length==0){
//                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2);
//                }else if(strs.length==1){
//                    QueryBuilder queryImage1 = QueryBuilders.wildcardQuery("tags.keyword", "*铁路*");
//                    QueryBuilder queryImage2 = QueryBuilders.wildcardQuery("tags.keyword", "*电力*");
//                    BoolQueryBuilder boolQueryBuilder2 = QueryBuilders.boolQuery().should(queryImage1).should(queryImage2);
//                    boolQueryBuilder =  QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2).must(boolQueryBuilder2);
//                }else if(strs.length==2){
//                    QueryBuilder queryImage1 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[0]+"*");
//                    QueryBuilder queryImage2 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[1]+"*");
//                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2).must(queryImage1).must(queryImage2);
//                }else if(strs.length==3){
//                    QueryBuilder queryImage1 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[0]+"*");
//                    QueryBuilder queryImage2 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[1]+"*");
//                    QueryBuilder queryImage3 = QueryBuilders.wildcardQuery("tags.keyword", "*"+strs[2]+"*");
//                    boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2).must(queryImage1).must(queryImage2).must(queryImage3);
//                }
            }
        }else{ //其他过滤
            String docType = "contentType:*" + contentType + "*";
            if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
                docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
            }
            queryStringQueryBuilder2 = QueryBuilders.queryStringQuery(docType);
            boolQueryBuilder = QueryBuilders.boolQuery().must(queryBuilder).must(termQueryBuilder).must(queryStringQueryBuilder2);
        }
//        String docType = "contentType:*" + contentType + "*";
//        if (!"text".equals(contentType) && !"pdf".equals(contentType) && !"msword".equals(contentType)) {
//            docType = "contentType:*" + contentType.replaceAll(",", "*  contentType:*") + "*";
//        }
//        QueryStringQueryBuilder queryStringQueryBuilder = QueryBuilders.queryStringQuery(docType);
//        QueryBuilder queryStringQueryBuilder = QueryBuilders.wildcardQuery("contentType", "*word*");

        // 如果是文库超级管理员，不加权限限制
        if (!adminFlag) {
            boolQueryBuilder.must(termsQueryBuilder);
        }
        SearchResponse response = doQuery(boolQueryBuilder, page,size);
        return handleHits(response);
    }

    */
/**
     * 关闭链接
     * @Title: close 
     * @author: WangBinBin
     *//*

    public void close() {
        if (this.client != null) {
            this.client.close();
        }
    }

}
*/
